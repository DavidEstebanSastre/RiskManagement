"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../common/utils");
const StableIdHelper_1 = require("./StableIdHelper");
const common_1 = require("../../common");
const i18next_1 = __importDefault(require("i18next"));
const __1 = require("../../..");
const ux_specification_types_1 = require("@sap/ux-specification-types");
function addArtifactTypeManifest(appSchema, customColumnDefinitionName) {
    const columnDefinition = appSchema.definitions[customColumnDefinitionName];
    if (columnDefinition) {
        for (const propertyId in columnDefinition.properties) {
            columnDefinition.properties[propertyId][common_1.SchemaTag.artifactType] = ux_specification_types_1.ArtifactType.Manifest;
        }
    }
}
/**
 * Sort function for properties in schema definitions.
 * @param definition - definition which contains list of properties, unsorted
 * @returns - list of properties, sorted by property index
 */
function sortPropertiesRecords(definition) {
    definition = typeof definition === 'object' ? definition : {};
    function sortByPropertyIndex() {
        return ([_key1, value1], [_key2, value2]) => value1[common_1.SchemaTag.propertyIndex] - value2[common_1.SchemaTag.propertyIndex];
    }
    const unsortedObjArr = [...Object.entries(definition.properties)];
    return unsortedObjArr.sort(sortByPropertyIndex());
}
/**
 * Method receives extension object and returns title/text.
 * @param extension - custom extension object from manifest.
 * @returns Title/text of custom extension.
 */
function getExtensionText(extension) {
    return 'header' in extension ? extension.header : extension.text;
}
/**
 * Adds a custom extension to the right position of a sorted array
 * @param extension - custom extension
 * @param sortedExtensionsArray - array of all entries(annotation entries and extensions), to be enhanced
 * @param targetIndex - index of the anchor entry
 * @param extId - ID of the new custom extension
 * @param newExtensionReference - schema reference of the new extension
 */
function addExtensionToSortedArray(extension, sortedExtensionsArray, targetIndex, extId, newExtensionReference) {
    var _a;
    const placement = ((_a = extension.position) === null || _a === void 0 ? void 0 : _a.placement) || ux_specification_types_1.v4.Placement.After;
    if (placement === ux_specification_types_1.v4.Placement.Before) {
        sortedExtensionsArray.splice(targetIndex, 0, [extId, newExtensionReference]);
    }
    else {
        sortedExtensionsArray.splice(targetIndex + 1, 0, [extId, newExtensionReference]);
    }
}
/**
 * Post-processing of custom extensions that are left after the first loop of adding extensions, i.e. custom extensions referring to other custom extensions
 * @param remainingExtensions - list of custom extensions that are left for post-processing
 * @param customColumnDefinitionName - custom extension definition name, different in LR and OP
 * @param sortedColumnsArray - sorted array of annotation-based extensions, to be updated
 * @param logger - logger for error messages
 */
function adjustCustomExtReferringToCustomExt(remainingExtensions, extensionDefinitionName, sortedExtArray, logger) {
    var _a, _b;
    for (const extId in remainingExtensions) {
        const extension = remainingExtensions[extId];
        // Detect description based on extension in manifest
        const description = getExtensionText(extension);
        const newCustomExt = {
            $ref: `${utils_1.DEFINITION_LINK_PREFIX}${extensionDefinitionName}`,
            description
        };
        if (((_a = extension.position) === null || _a === void 0 ? void 0 : _a.anchor) && ((_b = extension.position) === null || _b === void 0 ? void 0 : _b.placement)) {
            const targetIndex = sortedExtArray.findIndex((element) => element[0] === extension.position.anchor);
            if (targetIndex > -1) {
                addExtensionToSortedArray(extension, sortedExtArray, targetIndex, extId, newCustomExt);
                delete remainingExtensions[extId];
            }
            else if (extId === extension.position.anchor ||
                Object.keys(remainingExtensions).indexOf(extension.position.anchor) === -1) {
                __1.log(logger, {
                    severity: "error" /* Error */,
                    message: i18next_1.default.t('INVALIDANCHOR', { id: extId, anchor: extension.position.anchor }),
                    location: {
                        path: common_1.MANIFESTPATH,
                        range: [ux_specification_types_1.ManifestSection.generic]
                    }
                });
                sortedExtArray.splice(sortedExtArray.length, 0, [extId, newCustomExt]);
                delete remainingExtensions[extId];
            }
        }
    }
    if (Object.keys(remainingExtensions).length > 0) {
        adjustCustomExtReferringToCustomExt(remainingExtensions, extensionDefinitionName, sortedExtArray, logger);
    }
}
/**
 * Returns anchor for extension. Priority:
 * 1. 'anchor' property in extension;
 * 2. When 'anchor' is not defined in extension and does calculation based placement and current list of extension and annotation entries.
 * @param extension - extension in manifest
 * @param sortedExtensionsArray - sorted array of annotation-based nodes, to be enhanced by extensions
 */
function getExtensionAnchor(extension, sortedExtensionsArray) {
    var _a, _b;
    // Default placement is After
    const placement = ((_a = extension.position) === null || _a === void 0 ? void 0 : _a.placement) || ux_specification_types_1.v4.Placement.After;
    let anchor = (_b = extension.position) === null || _b === void 0 ? void 0 : _b.anchor;
    if (!anchor) {
        // Simulate runtime behavior - if there no anchor, then logic uses first or last annotation node
        // In some cases last extension can be previously inserted extension - in such case we still need use annotation node
        const index = placement === ux_specification_types_1.v4.Placement.Before ? 0 : sortedExtensionsArray.length - 1;
        anchor = sortedExtensionsArray[index] ? sortedExtensionsArray[index][0] : undefined;
    }
    return anchor;
}
/**
 * Adds extension at the right position of the sorted array of annotation-based nodes
 * @param extensions - list of extensions in manifest
 * @param sortedExtensionsArray - sorted array of annotation-based nodes, to be enhanced by extensions
 * @param extensionDefinitionName - extension definition name, different in LR and OP
 * @param loggeloggerr - logger for error messages
 */
function addExtensionToArray(extensions, sortedExtensionsArray, extensionDefinitionName, templatePropertyName = 'template', logger) {
    const annotationEntries = [...sortedExtensionsArray];
    const localExtensions = Object.assign({}, extensions);
    for (const extensionId in localExtensions) {
        const extension = localExtensions[extensionId];
        if (!(templatePropertyName in extension)) {
            // Skip regular entries(columns, actions, etc.)
            delete localExtensions[extensionId];
            continue;
        }
        const newExtensionReference = {
            $ref: `${utils_1.DEFINITION_LINK_PREFIX}${extensionDefinitionName}`,
            description: getExtensionText(extension) || extensionId
        };
        const anchor = getExtensionAnchor(extension, annotationEntries);
        if (anchor) {
            const targetIndex = sortedExtensionsArray.findIndex((element) => element[0] === anchor);
            if (targetIndex > -1) {
                addExtensionToSortedArray(extension, sortedExtensionsArray, targetIndex, extensionId, newExtensionReference);
                delete localExtensions[extensionId];
            }
        }
        else {
            // Empty array - no any anchor to reference to
            sortedExtensionsArray.push([extensionId, newExtensionReference]);
            delete localExtensions[extensionId];
        }
    }
    if (Object.keys(localExtensions).length > 0) {
        //Second loop is necessary for custom columns that refer to custom columns
        adjustCustomExtReferringToCustomExt(localExtensions, extensionDefinitionName, sortedExtensionsArray, logger);
    }
    return sortedExtensionsArray;
}
/**
 * Common function for enhancing the LineItems definition of app schema by custom columns
 * @param appSchema - app-specific JSON schema
 * @param v4Page - actual page in the manifest
 * @param logger - logger for error messages
 * @param customColumnDefinitionName - custom column definition name
 * @param sectionId - identifier of the current object page section in schema
 * @param sectionIdInManifest - identifier of the current object page section in manifest
 */
function addCustomColumnDefinition(appSchema, v4Page, logger, customColumnDefinitionName = common_1.DefinitionName.CustomColumn, sectionId, sectionIdInManifest) {
    var _a, _b, _c, _d;
    const lineItemId = sectionId || common_1.DefinitionName.LineItems;
    const lineItems = appSchema.definitions[lineItemId];
    if (!lineItems) {
        return;
    }
    //sort line items
    let sortedColumnsArray = sortPropertiesRecords(lineItems);
    const id = sectionIdInManifest ? sectionIdInManifest.replace(/::/g, '/') : `@${"com.sap.vocabularies.UI.v1.LineItem" /* LineItem */}`;
    const columns = (_d = (_c = (_b = (_a = v4Page.options) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.controlConfiguration) === null || _c === void 0 ? void 0 : _c[id]) === null || _d === void 0 ? void 0 : _d['columns'];
    if (columns) {
        sortedColumnsArray = addExtensionToArray(columns, sortedColumnsArray, customColumnDefinitionName, undefined, logger);
    }
    //Adjust propertyIndex
    for (let index = 0; index < sortedColumnsArray.length; index++) {
        sortedColumnsArray[index][1][common_1.SchemaTag.propertyIndex] = index;
    }
    const sortedColumnsAsObject = {};
    sortedColumnsArray.forEach(([key, value]) => (sortedColumnsAsObject[key] = value));
    appSchema.definitions[lineItemId].properties = sortedColumnsAsObject;
    //Add artifact type 'Manifest' to TableCustomColumn properties
    addArtifactTypeManifest(appSchema, customColumnDefinitionName);
}
exports.addCustomColumnDefinition = addCustomColumnDefinition;
/**
 * Processes a LineItem record of type DataFieldForAction during app schema generation
 * @param appSchema - the app specific schema that shall get enhanced
 * @param entityType - the entity type as part of the AVT ConvertedMetadata
 * @param actions - actions definition in schema, parent object
 * @param lineItemPath - annotation path to the line item
 * @param lineItemRecord - actual record of the line item collection
 * @param recordIndex - record index in the collection
 */
function handleActionRecord(appSchema, entityType, actionsDefinition, lineItemPath, lineItemRecord, lineItemId, recordIndex) {
    // Action but not inline action
    if (lineItemRecord.Determining !== true) {
        //no footer bar -> toolbar action
        let actionDefinitionName;
        if (lineItemId.startsWith(common_1.DefinitionName.LineItemsOfView)) {
            actionDefinitionName = common_1.DefinitionName.ViewToolBarAction;
        }
        else if (lineItemId.startsWith(common_1.DefinitionName.LineItems)) {
            actionDefinitionName = common_1.DefinitionName.ToolBarAction;
        }
        else {
            actionDefinitionName = common_1.DefinitionName.ObjectPageToolBarAction;
        }
        const actionId = lineItemRecord.Action.replace('/', '??');
        const description = utils_1.getDataFieldDescription(lineItemRecord, entityType);
        const prefix = lineItemRecord.$Type.split(`${common_1.UIVOCABULARY}.`)[1];
        const actions = (actionsDefinition.properties[`${prefix}::${lineItemRecord.Action}`] = {
            $ref: common_1.getFacetDefinitionLink(actionDefinitionName, common_1.prepareRef(actionId)),
            description
        });
        actions[common_1.SchemaTag.propertyIndex] = recordIndex;
        actions[common_1.SchemaTag.annotationType] = lineItemRecord.$Type;
        const action = common_1.parseSchemaDefinition(actionDefinitionName, common_1.prepareRef(actionId), appSchema);
        action[common_1.SchemaTag.annotationPath] = `${lineItemPath}/${recordIndex}`;
    }
}
exports.handleActionRecord = handleActionRecord;
/**
 * Processes a LineItem record of type DataField during app schema generation
 * @param lineItem - object comprising the line item information:
 * { lineItemRecord, lineItemId, lineItemPath }
 * @param appSchema - the app specific schema that shall get enhanced
 * @param columnDefinitionName - Schema definition name for the column
 * @param entityType - the entity type as part of the AVT ConvertedMetadata
 * @param recordIndex - record index in the collection
 * @param {ConvertedMetadata} oDataServiceAVT - AVT information
 */
function handleLineItemRecord(lineItem, appSchema, columnDefinitionName, entityType, recordIndex, oDataServiceAVT) {
    var _a, _b, _c, _d, _e;
    const lineItemId = lineItem['lineItemId'];
    const lineItemRecord = lineItem['lineItemRecord'];
    if ((_a = lineItemRecord['Target']) === null || _a === void 0 ? void 0 : _a['value']) {
        const regex = `@${utils_1.findAlias(common_1.UIVOCABULARY, oDataServiceAVT)}.`;
        lineItemRecord['Target']['value'] = lineItemRecord['Target']['value'].replace(regex, '@');
    }
    const schemaKey = StableIdHelper_1.getStableIdPartFromDataField(lineItemRecord);
    if (schemaKey) {
        const properties = appSchema.definitions[lineItemId].properties;
        properties[schemaKey] = {
            $ref: utils_1.DEFINITION_LINK_PREFIX + columnDefinitionName,
            description: utils_1.getDataFieldDescription(lineItemRecord, entityType)
        };
        properties[schemaKey][common_1.SchemaTag.annotationType] = lineItemRecord === null || lineItemRecord === void 0 ? void 0 : lineItemRecord.$Type;
        properties[schemaKey][common_1.SchemaTag.annotationPath] = `${lineItem['lineItemPath']}/${recordIndex}`;
        properties[schemaKey][common_1.SchemaTag.propertyIndex] = recordIndex;
        if ((_c = (_b = lineItemRecord['Value']) === null || _b === void 0 ? void 0 : _b.$target) === null || _c === void 0 ? void 0 : _c.type) {
            properties[schemaKey][common_1.SchemaTag.dataType] = (_e = (_d = lineItemRecord['Value']) === null || _d === void 0 ? void 0 : _d.$target) === null || _e === void 0 ? void 0 : _e.type.replace('Edm.', '');
        }
    }
}
/**
 * Adds the line item definition, columns and actions to the app schema (for the list report or an object page section comprising a table)
 * @param appSchema - the app specific schema that shall get enhanced
 * @param lineItemAnnotation - the UI.LineItem annotation, comprising all records
 * @param entityType - the entity type as part of the AVT ConvertedMetadata
 * @param {ConvertedMetadata} oDataServiceAVT - complete service information, as returned by Annotation Vocabularies Tool
 * @param lineItemId - in case of OP the parameter must be passed to distinguish the OP tables;
 *                     in case of LR or ALP 'LineItems' is passed.
 * @param columnDefinitionName - name of the column definition, i.e. TableColumn or ObjectPageTableColumn
 * @param customColumnDefinitionName - name of the custom column definition
 */
function addLineItemsType(appSchema, lineItemAnnotation, entityType, oDataServiceAVT, lineItemId, columnDefinitionName = common_1.DefinitionName.TableColumn, customColumnDefinitionName = common_1.DefinitionName.CustomColumn, customActionDefinitionName = common_1.DefinitionName.CustomAction) {
    const { actions, lineItemPath } = common_1.addCommonLineItemDefinitions(appSchema, lineItemAnnotation, entityType, lineItemId, customColumnDefinitionName, customActionDefinitionName);
    if (!lineItemAnnotation) {
        return;
    }
    let i = 0;
    lineItemAnnotation.forEach((lineItemRecord) => {
        if ((lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */ ||
            lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */) &&
            (lineItemRecord.Inline !== true || lineItemRecord.Determining === true)) {
            handleActionRecord(appSchema, entityType, actions, lineItemPath, lineItemRecord, lineItemId, i);
        }
        else {
            const lineItem = { lineItemRecord, lineItemId, lineItemPath };
            const columnDefinition = lineItemRecord.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */
                ? `${columnDefinitionName}Action`
                : columnDefinitionName;
            handleLineItemRecord(lineItem, appSchema, columnDefinition, entityType, i, oDataServiceAVT);
        }
        i++;
    });
}
exports.addLineItemsType = addLineItemsType;
/**
 * Adds an enum or value help to position > anchor of custom column
 * @param appSchema - app specific JSON schema
 * @param lineItemId - ID of the current line item in schema
 * @param v4Page - current page in manifest
 * @param positionName - ID of the definition of custom column position in schema
 * @param sectionIdInManifest - identifier of the current object page section in manifest
 */
function addFragmentEnumForAnchor(appSchema, lineItemId, v4Page, positionName = common_1.DefinitionName.Position, sectionIdInManifest) {
    var _a, _b, _c, _d, _e;
    const columns = (_a = appSchema.definitions[lineItemId]) === null || _a === void 0 ? void 0 : _a.properties;
    const enumEntries = [];
    if (columns) {
        for (const key in columns) {
            if (key !== 'custom') {
                enumEntries.push(key);
            }
        }
    }
    const id = lineItemId !== common_1.DefinitionName.LineItems ? sectionIdInManifest : `@${"com.sap.vocabularies.UI.v1.LineItem" /* LineItem */}`;
    const columnsInManifest = (_e = (_d = (_c = (_b = v4Page.options) === null || _b === void 0 ? void 0 : _b.settings) === null || _c === void 0 ? void 0 : _c.controlConfiguration) === null || _d === void 0 ? void 0 : _d[id]) === null || _e === void 0 ? void 0 : _e['columns'];
    if (columnsInManifest) {
        for (const key in columnsInManifest) {
            if (enumEntries.indexOf(key) === -1) {
                enumEntries.push(key);
            }
        }
    }
    if (enumEntries.length > 0) {
        appSchema.definitions[positionName].properties['anchor']['enum'] = enumEntries;
    }
}
exports.addFragmentEnumForAnchor = addFragmentEnumForAnchor;
/**
 * Adds an enum or value help to position > anchor of custom column
 * @param appSchema - app specific JSON schema
 * @param definitionId - definition key of actions
 * @param positionName - target definition to update
 */
function addEnumForActionAnchor(appSchema, definitionId, positionName = common_1.DefinitionName.CustomActionPosition) {
    common_1.addDescriptiveEnumDefinition(appSchema, appSchema.definitions[definitionId], {
        definition: positionName,
        property: 'anchor'
    });
}
exports.addEnumForActionAnchor = addEnumForActionAnchor;
/**
 * Find the relevant V4 page under the routing targets of manifest,json
 * @param pages - list of all pages in manifest
 * @param pageName - search criterion: page name
 * @param entitySet - search criterion: entity set
 * @param logger - logger for messages
 * @returns the page definition in manifest (if found)
 */
function findPageV4(pages, pageName, entitySet, logger) {
    var _a, _b;
    let v4Page;
    if (entitySet) {
        for (const i in pages) {
            if (((_b = (_a = pages[i].options) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.entitySet) === entitySet.name &&
                (pages[i].name === pageName ||
                    (pageName === ux_specification_types_1.v4.FE_TEMPLATE_V4_ALP && pages[i].name === ux_specification_types_1.v4.FE_TEMPLATE_V4_LIST_REPORT))) {
                v4Page = pages[i];
                break;
            }
        }
    }
    if (!v4Page) {
        __1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOENTITYSET', { entitySet }),
            location: {
                path: common_1.MANIFESTPATH,
                range: [ux_specification_types_1.ManifestSection.generic]
            }
        });
    }
    return v4Page;
}
exports.findPageV4 = findPageV4;
/**
 * Depending on the template type, strip down the app schema so that only the relevant views are part of it
 * @param {Definition} appSchema - app specific JSON schema, to be adjusted
 * @param {GenerateAppSchemaParameters} generateParameters - object comprising all input parameters
 * @returns the right definition name for the table in the schema
 */
function alignSchemaWithTemplateType(appSchema, generateParameters) {
    let tableDefinitionName;
    const tableDefinition = appSchema.properties[common_1.PropertyName.table];
    if (generateParameters.templateType === utils_1.TemplateType.AnalyticalListPageV4) {
        tableDefinitionName = common_1.DefinitionName.ALPTableView;
        delete tableDefinition.anyOf;
        tableDefinition.$ref = `${utils_1.DEFINITION_LINK_PREFIX}${common_1.DefinitionName.ALPTableView}`;
        delete appSchema.definitions[common_1.DefinitionName.Table];
        delete appSchema.definitions[common_1.DefinitionName.LRChartView];
        delete appSchema.definitions[common_1.DefinitionName.LRTableView];
        delete appSchema.definitions[common_1.DefinitionName.MultiTableModeV4];
    }
    else if (generateParameters.templateType === utils_1.TemplateType.ListReportObjectPageV4) {
        tableDefinitionName = common_1.DefinitionName.Table;
        delete tableDefinition.anyOf;
        tableDefinition.$ref = `${utils_1.DEFINITION_LINK_PREFIX}${common_1.DefinitionName.Table}`;
        appSchema.definitions[tableDefinitionName].properties[common_1.PropertyName.annotationPath][common_1.SchemaTag.hidden] = true;
        delete appSchema.definitions[common_1.DefinitionName.ALPTableView];
        appSchema.properties[common_1.PropertyName.defaultPath][common_1.SchemaTag.hidden] = true;
    }
    return tableDefinitionName;
}
exports.alignSchemaWithTemplateType = alignSchemaWithTemplateType;
/**
 * Common function for enhancing the LineItems definition of app schema by custom columns
 * @param appSchema - app-specific JSON schema
 * @param v4Page - actual page in the manifest
 * @param logger - logger for error messages
 * @param customColumnDefinitionName - custom column definition name
 * @param sectionId - identifier of the current object page section in schema
 * @param sectionIdInManifest - identifier of the current object page section in manifest
 */
function addCustomActionDefinition(appSchema, v4Page, logger, customColumnDefinitionName = common_1.DefinitionName.CustomAction, sectionId = '', sectionIdInManifest = '') {
    var _a, _b, _c, _d;
    const definition = appSchema.definitions[sectionId];
    if (!definition) {
        return;
    }
    // Sort existing actions
    let sortedActionsArray = sortPropertiesRecords(definition);
    const id = sectionIdInManifest ? sectionIdInManifest.replace(/::/g, '/') : `@${"com.sap.vocabularies.UI.v1.LineItem" /* LineItem */}`;
    const actions = (_d = (_c = (_b = (_a = v4Page.options) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.controlConfiguration) === null || _c === void 0 ? void 0 : _c[id]) === null || _d === void 0 ? void 0 : _d['actions'];
    if (actions) {
        sortedActionsArray = addExtensionToArray(actions, sortedActionsArray, customColumnDefinitionName, 'press', logger);
    }
    // Adjust propertyIndex
    for (let index = 0; index < sortedActionsArray.length; index++) {
        sortedActionsArray[index][1][common_1.SchemaTag.propertyIndex] = index;
    }
    const sortedActionsAsObject = {};
    sortedActionsArray.forEach(([key, value]) => (sortedActionsAsObject[key] = value));
    appSchema.definitions[sectionId].properties = sortedActionsAsObject;
    // Add artifact type 'Manifest' to TableCustomColumn properties
    addArtifactTypeManifest(appSchema, customColumnDefinitionName);
}
exports.addCustomActionDefinition = addCustomActionDefinition;
//# sourceMappingURL=utils.js.map