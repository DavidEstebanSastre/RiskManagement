"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ux_specification_types_1 = require("@sap/ux-specification-types");
const types_1 = require("./types");
const utils_1 = require("./utils");
/**
 * Checks if custom page is supported (FPM)
 * @param {v4.Page|v2.Page} page - custom page
 * @returns boolean - custom page uses fpm
 */
function isFPMCustomPage(page) {
    if (page.pageType === ux_specification_types_1.PageTypeV4.CustomPage &&
        page.view.template === ux_specification_types_1.v4.FE_TEMPLATE_V4_CUSTOM_PAGE) {
        return true;
    }
    return false;
}
/**
 * Splits and returns the name of a custom page
 * @param {v4.Page|v2.Page} page - custom page
 * @returns {string} custom page name
 */
function getCustomPageName(page) {
    var _a;
    const targetName = (_a = page.view.name) === null || _a === void 0 ? void 0 : _a.split('.');
    return targetName[targetName.length - 1];
}
/**
 * Returns the view type of a custom page
 * @param {v4.Page|v2.Page} page - custom page
 * @param {Application} app - application
 * @returns {string} view type
 */
function getViewType(page, app) {
    var _a, _b, _c;
    const viewType = ((_b = (_a = page) === null || _a === void 0 ? void 0 : _a.view) === null || _b === void 0 ? void 0 : _b.viewType) || ((_c = app.settings) === null || _c === void 0 ? void 0 : _c.viewType);
    return (viewType || ux_specification_types_1.ViewTypes.XML).toLowerCase();
}
/**
 * Returns the view path and file name of the custom page
 * @param {v4.Page|v2.Page} page - custom page
 * @param {Application} app - application
 * @param {string} viewName - name of view
 * @returns {string} view path
 */
function getViewPath(page, app, viewPath) {
    var _a, _b;
    const splitViewPath = (splitPath) => {
        var _a;
        return (_a = splitPath.split(`${app.id}.`)[1]) === null || _a === void 0 ? void 0 : _a.split('.');
    };
    const appSettings = app.settings;
    const appPath = ((_a = page.view) === null || _a === void 0 ? void 0 : _a.path) || (appSettings === null || appSettings === void 0 ? void 0 : appSettings.path);
    const pageName = (_b = page.view) === null || _b === void 0 ? void 0 : _b.name;
    if (pageName === null || pageName === void 0 ? void 0 : pageName.includes(app.id)) {
        viewPath = splitViewPath(pageName);
    }
    else if (appPath === null || appPath === void 0 ? void 0 : appPath.includes(app.id)) {
        viewPath = [...splitViewPath(appPath), ...pageName.split('.')];
    }
    const [pathParts, fileName] = [viewPath.slice(0, -1), ...viewPath.slice(-1)];
    return { viewPath: pathParts, fileName };
}
/**
 * Returns the page name and path of a custom page
 * @param {v4.Page|v2.Page} page - custom page
 * @param {string} appId - Application id
 * @returns page name
 */
function getCustomPagePath(page, app) {
    const viewName = page.entitySet || getCustomPageName(page);
    const { viewPath, fileName } = getViewPath(page, app, [viewName]);
    const viewType = getViewType(page, app);
    // we always use '/' as separator so that snapshot tests generated from Windows do not fail on Jenkins
    return [...viewPath, `${fileName}.view.${viewType}`].join('/');
}
class AppProvider {
    constructor(manifest, schemas, home, pages, version, settings, logger) {
        // Store controller names which should be handled lately
        this.unhandledControllers = [];
        const schemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.Application);
        this.app = Object.assign({ $schema: schemaFile.path, id: manifest['sap.app'].id, pages,
            home, target: {
                fioriElements: version,
                odata: version === ux_specification_types_1.FioriElementsVersion.v2 ? ux_specification_types_1.OdataVersion.v2 : ux_specification_types_1.OdataVersion.v4
            } }, (settings && { settings }));
        this.schemas = schemas;
        this.logger = logger;
    }
    /**
     * Create config files for app (app.json) and pages (pages/{name}.json).
     * This is basically a copy of createFiles optimized to be used in FTFS:
     * it always uses posix path notation with forward slash (/)
     * @param {ConvertedMetadata} oDataServiceAVT - Complete service information, as returned by annotation vocabularies tool
     * @returns app and page files as separate objects
     */
    createConfigFiles() {
        const pageConfigs = {};
        const appConfig = {};
        let page;
        // add schema reference to all pages
        for (const pageId in this.app.pages) {
            page = this.app.pages[pageId];
            if (isFPMCustomPage(page)) {
                const $filePath = getCustomPagePath(page, this.app);
                const { path: $schema } = utils_1.getSchemaFilePath(page.pageType);
                const config = { $filePath, $schema };
                pageConfigs[`${types_1.DirName.Pages}/${pageId}.json`] = config;
            }
            else if (page.config) {
                const config = page.config;
                const schemaFile = utils_1.getSchemaFilePath(page.pageType, page.entitySet);
                if (this.schemas[schemaFile.filename]) {
                    config.$schema = schemaFile.path;
                }
                else {
                    const genericSchemaFile = utils_1.getSchemaFilePath(page.pageType);
                    config.$schema = genericSchemaFile.path;
                }
                pageConfigs[`${types_1.DirName.Pages}/${pageId}.json`] = config;
            }
        }
        // remove config before converting to JSON
        const app = JSON.parse(JSON.stringify(this.app));
        for (const pageId in app.pages) {
            delete app.pages[pageId].config;
        }
        appConfig[types_1.FileName.App] = app;
        return { appConfig, pageConfigs };
    }
}
exports.AppProvider = AppProvider;
//# sourceMappingURL=appProvider.js.map