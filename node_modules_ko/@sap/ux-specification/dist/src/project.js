"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const readFile = async (path) => {
    return new Promise((resolve, reject) => {
        fs_1.readFile(path, { encoding: 'utf8' }, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
};
const readJSON = async (path) => {
    return JSON.parse(await readFile(path));
};
exports.readDirectory = async (path) => {
    return new Promise((resolve, reject) => {
        fs_1.readdir(path, { encoding: 'utf8' }, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
};
exports.isDirectory = async (path) => {
    return new Promise((resolve) => {
        fs_1.stat(path, (err, stats) => {
            if (err) {
                resolve(false);
            }
            else {
                resolve(stats.isDirectory());
            }
        });
    });
};
const resourceExists = async (path) => {
    return new Promise((resolve) => {
        fs_1.exists(path, (doesExist) => {
            resolve(doesExist);
        });
    });
};
const getManifest = async (path) => {
    return readJSON(path_1.join(path, 'manifest.json'));
};
exports.getChanges = async (webapp) => {
    const changes = [];
    const changesDirectory = path_1.join(webapp, 'changes');
    if (!(await resourceExists(changesDirectory))) {
        return changes;
    }
    const extensions = [
        '.change',
        '.variant',
        '.ctrl_variant',
        '.ctrl_variant_change',
        '.ctrl_variant_management_change'
    ];
    const files = await exports.readDirectory(changesDirectory);
    for (const file of files) {
        if (extensions.some((ext) => file.endsWith(ext))) {
            changes.push(await readFile(path_1.join(changesDirectory, file)));
        }
    }
    return changes;
};
const getFragments = async (webAppPath) => {
    const fragments = [];
    const directoryPath = path_1.join(webAppPath, 'ext', 'fragments');
    if (!(await resourceExists(directoryPath))) {
        return fragments;
    }
    const files = await exports.readDirectory(directoryPath);
    for (const file of files) {
        const filePath = path_1.join(directoryPath, file);
        const data = await readFile(filePath);
        fragments.push({
            dataSourceUri: filePath,
            fileContent: data
        });
    }
    return fragments;
};
const getAnnotations = async (manifest, webAppPath) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const annotationData = [];
    const serviceDataSources = (_a = manifest === null || manifest === void 0 ? void 0 : manifest['sap.app']) === null || _a === void 0 ? void 0 : _a.dataSources;
    if ((_c = (_b = serviceDataSources === null || serviceDataSources === void 0 ? void 0 : serviceDataSources.mainService) === null || _b === void 0 ? void 0 : _b.settings) === null || _c === void 0 ? void 0 : _c.localUri) {
        const metadataPath = path_1.join(webAppPath, serviceDataSources.mainService.settings.localUri);
        annotationData.push({
            dataSourceUri: metadataPath,
            fileContent: await readFile(metadataPath)
        });
    }
    if ((_e = (_d = serviceDataSources === null || serviceDataSources === void 0 ? void 0 : serviceDataSources.mainService) === null || _d === void 0 ? void 0 : _d.settings) === null || _e === void 0 ? void 0 : _e.annotations) {
        for (const annotationRef of serviceDataSources.mainService.settings.annotations) {
            if ((_g = (_f = serviceDataSources[annotationRef]) === null || _f === void 0 ? void 0 : _f.settings) === null || _g === void 0 ? void 0 : _g.localUri) {
                const annotationFilePath = path_1.join(webAppPath, serviceDataSources[annotationRef].settings.localUri);
                annotationData.push({
                    dataSourceUri: annotationFilePath,
                    fileContent: await readFile(annotationFilePath)
                });
            }
        }
    }
    //Consider CAP/multiple services
    if (annotationData.length === 0) {
        for (const key in serviceDataSources) {
            const dataSource = serviceDataSources[key];
            if ((dataSource === null || dataSource === void 0 ? void 0 : dataSource.type) === 'ODataAnnotation' && ((_h = dataSource === null || dataSource === void 0 ? void 0 : dataSource.settings) === null || _h === void 0 ? void 0 : _h.localUri)) {
                const annotationFilePath = path_1.join(webAppPath, dataSource.settings.localUri);
                annotationData.push({
                    dataSourceUri: annotationFilePath,
                    fileContent: await readFile(annotationFilePath)
                });
            }
        }
    }
    return annotationData;
};
/**
 * Get the project artefacts, like manifest, service metadata, annotations
 * @param root - project root where package.json is
 */
exports.getProject = async (root) => {
    const name = path_1.basename(root);
    const webappPath = path_1.join(root, 'webapp');
    const manifest = await getManifest(webappPath);
    const annotations = await getAnnotations(manifest, webappPath);
    const changes = await exports.getChanges(webappPath);
    const fragments = await getFragments(webappPath);
    return {
        root,
        name,
        manifest,
        annotations,
        changes,
        fragments
    };
};
//# sourceMappingURL=project.js.map